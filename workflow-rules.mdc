# 工作流程规范

> **本文档定义 AI 的具体工作方法和流程**，是核心原则的实践指南。

---

## Bug排查流程

### 核心原则

**通过验证逐步缩小问题范围，让用户看到完整的分析过程**

排查bug时，不能直接猜测或跳跃式分析，必须通过实际验证来逐步确定问题出在哪一层。

### 禁止的错误模式

```
用户：X功能有bug
AI：我觉得可能是Y的问题（未验证）
    建议改Z（直接给方案）

结果：方案基于猜测，可能南辕北辙
```

### 正确的排查流程

```
用户：X功能有bug
AI：
  1. 理解问题：复述问题，确认理解正确
  2. 假设验证：提出2-3个可能的原因假设
  3. 逐层验证：从最底层开始验证
  
     验证1：DB层 - 查询数据库，数据是否存在？
     结论1：[数据存在] / [数据缺失]
     
     验证2：API层 - 调用接口，能否正确返回？
     结论2：[接口正常] / [接口异常]
     
     验证3：前端层 - 查看页面，数据是否显示？
     结论3：[显示正常] / [显示异常]
  
  4. 定位问题：根据验证结果，明确指出问题在哪一层
  5. 分析原因：阅读相关代码，找出根本原因
  6. 制定方案：提出修复方案，等待用户确认
  7. 实施修复：获得确认后执行修改
```

### 逐层验证方法

#### 第1层：数据层验证（DB Layer）

**目的**：确认数据本身是否存在、是否正确

```bash
# 验证数据是否存在
node -e "
const mysql = require('mysql2/promise');
(async () => {
  const conn = await mysql.createConnection({...});
  const [rows] = await conn.execute('SELECT * FROM users WHERE id = ?', ['123']);
  console.table(rows);
  await conn.end();
})();
"
```

**输出格式**：
```
═══════════════════════════════════════
【第1步：DB层验证】
═══════════════════════════════════════
查询：SELECT * FROM users WHERE id = '123'
结果：找到 1 条记录
[显示数据表格]

结论：DB层数据正常
═══════════════════════════════════════
```

#### 第2层：API层验证

**目的**：确认后端接口是否能正确处理和返回数据

```bash
# 验证API是否正常
curl --max-time 5 \
  "http://localhost:18100/api/users/123" \
  -H "Authorization: Bearer ${TOKEN}"
```

**输出格式**：
```
═══════════════════════════════════════
【第2步：API层验证】
═══════════════════════════════════════
请求：GET /api/users/123
响应：{"success": true, "data": {...}}

结论：
- DB层：数据存在
- API层：接口正常返回

问题范围缩小至：前端层
═══════════════════════════════════════
```

#### 第3层：前端层验证

**目的**：确认前端是否正确接收和显示数据

```typescript
// 在浏览器控制台执行
console.log('前端状态:', {
  apiResponse: window.lastApiResponse,
  displayedData: document.querySelector('.user-item')?.textContent
});
```

### 范围缩小策略

使用二分法逐步缩小问题范围：

```
全链路：浏览器 → 前端代码 → API请求 → 后端代码 → 数据库

第1次验证：检查数据库
  - [数据存在] → 问题在上层
  - [数据不存在] → 问题定位：数据写入逻辑

第2次验证：检查API
  - [API正常] → 问题在前端
  - [API异常] → 问题在后端

第3次验证：检查前端
  - 找到具体的文件、函数、代码行
```

---

## 代码修改流程

### 完整性检查（5层检查法）

**核心原则**：修改前识别所有相关位置，避免遗漏导致的补充提交。

```
完整性检查的目的：
- 确保找到所有需要修改的位置
- 避免"改了这儿漏了那儿"
- 支持将完整的修改拆分成多个原子commit

完整性 ≠ 一个commit
完整性 = 不遗漏相关修改
```

#### 第1层：多维度关键词搜索

```bash
# 业务层面
grep -rn "业务词1\|业务词2" src/

# 代码符号层面
grep -rn "函数名\|变量名" src/

# 技术实现层面
grep -rn "技术特征" src/
```

#### 第2层：功能流程分析

```
输入路径分析：
  1. 用户操作A → 事件处理A
  2. 用户操作B → 事件处理B

数据流分析：
  目标数据在哪些地方被：
  - 读取
  - 修改
  - 验证
  - 展示
```

#### 第3层：文件结构检查

```bash
# 列出所有函数定义
grep -n "export.*function\|const.*=.*(" file.tsx

# 列出所有Hooks
grep -n "useState\|useEffect" file.tsx
```

#### 第4层：代码阅读验证

- 完整阅读相关函数代码
- 检查所有分支逻辑（if/else）
- 验证注释是否需要更新
- 确认错误提示一致性

#### 第5层：交叉验证检查表

```
必须同步修改：
- [ ] 代码逻辑
- [ ] TypeScript类型
- [ ] 函数注释
- [ ] 错误提示文案
- [ ] 相关文档
```

### 修改执行清单

**验证环节**
- [ ] 每个假设都通过实际验证
- [ ] 验证结果以结构化格式输出
- [ ] 使用 [通过]/[失败] 明确标注验证结论
- [ ] 每次验证后说明当前问题范围

**分析环节**
- [ ] 列出2-3个可能的原因假设
- [ ] 从底层（DB）到上层（前端）逐层验证
- [ ] 定位到具体的代码文件和行号

---

## 验证流程

### 验证原则

AI主动验证，展示结果，不推卸责任，工作可追溯可验证。

### 验证优先级

```
1. 用户操作路径验证（最重要）
   └─ 登录 → 菜单 → 页面 → 功能 → 结果
   
2. 底层API验证
   └─ 接口 → 数据 → 状态
   
3. 数据库验证
   └─ 数据存在性 → 数据正确性
```

### 验证输出格式

**注意**：以下输出格式中可以使用状态标记（如 [通过]/[失败]）提高可读性，但在代码注释中禁止使用装饰性标记。

```
功能已完成并验证通过！

【验证流程】
1. 使用测试账号登录 [通过]
2. 点击目标菜单 [通过]
3. 页面正常加载 [通过]
4. 功能正常工作 [通过]

【验证截图】
[附截图]

【技术验证】
API: 接口返回正确 [通过]
数据库：数据一致 [通过]
```

---

## Git工作流

### 核心原则：边改边暂存

```bash
1. 修改一个小单元（函数/组件/配置）
2. 验证修改结果正确
3. git add <file>  # 立即暂存
4. 继续下一个修改
5. 如出错：git restore <file>  # 恢复到上次暂存
```

### 禁止操作

**禁止的文件操作**：
- `sed -i '' -e ...`
- `awk '...' file > temp && mv temp file`
- `echo "content" > file`
- `git checkout file`（使用 `git restore` 代替）

**关于自动格式化工具**：

禁止场景：
- 临时性的批量格式化（未经审查）
- 开发中途突然运行全局格式化
- 格式化未修改的文件

推荐场景：
- 项目初期配置好 `.prettierrc` 和 `.eslintrc`
- 使用 git hooks（husky + lint-staged）自动格式化暂存文件
- IDE 配置保存时自动格式化当前文件
- 只格式化本次修改的文件

### 推荐工具

- IDE提供的编辑工具
- `git restore <file>`
- `git diff`
- `git status`

### 错误恢复

| 场景 | 恢复命令 |
|---|---|
| 刚修改完，发现有问题 | `git restore file` |
| 已git add，想撤销暂存 | `git restore --staged file && git restore file` |
| 想恢复到更早的版本 | `git restore --source=<commit> file` |

---

## Git提交规范

### 核心理念：原子提交

```
原子提交 = 一个独立的、完整的、可测试的变更单元

推荐做法：
- 一个需求可以拆分成多个原子commit
- 每个commit都能独立编译、测试、回滚

禁止做法：
- 一个commit包含多个不相关的需求
- 因为遗漏而反复修改同一处
```

### 提交格式

```
<type>(<scope>): <subject>

<body>

<footer>
```

### type类型

- `feat`: 新功能
- `fix`: Bug修复
- `docs`: 文档更新
- `style`: 代码格式
- `refactor`: 重构
- `perf`: 性能优化
- `test`: 测试相关
- `chore`: 构建/工具链

### subject规范

- 使用中文描述
- 不超过50个字符
- 首字母小写
- 结尾不加句号

### body规范（记录完整工作过程）

- [检查过程]: 完整性检查的结果，识别了哪些位置
- [修改范围]: 修改了哪些文件/模块/函数
- [验证情况]: 用户操作路径/API/数据库验证结果
- [设计考虑]: 为什么这样做，有什么权衡

### 示例

```
feat(user): 用户筛选 - 添加UI组件 (#123)

[检查过程]:
- 多维度搜索：筛选/filter/search 相关代码
- 数据流分析：用户列表 → 筛选条件 → 过滤结果
- 识别修改：需要修改3个文件

[修改范围]:
- src/components/UserList.tsx: 添加筛选UI组件
- src/types/user.ts: 新增FilterParams类型定义

[验证情况]:
- 用户操作路径：登录 → 用户管理 → 选择部门筛选 (通过)
- UI交互：筛选条件变化时列表正确更新 (通过)

[设计考虑]:
- 筛选条件存储在URL参数，支持刷新保持状态
- 使用防抖优化搜索性能（300ms）
```

---

## 代码质量标准

### 编译检查

- 所有代码修改后必须编译通过
- 不允许跳过编译检查

### 命名规范

- 变量/函数名：清晰、有意义，避免单字母
- 组件名：PascalCase
- 函数名：camelCase
- 常量名：UPPER_SNAKE_CASE

### 代码可维护性

**函数长度**：
- 单个函数不超过50行 → 超过必须拆分（除非特殊情况）
- 判断标准：函数的单一职责

**嵌套深度**：
- 不超过3层 → 超过必须重构
- 重构方式：提前return、提取函数

**注释要求**：
- 必须添加注释：非常规算法、业务规则、暂时性方案
- 不需要注释：代码本身清晰自解释的

**重复代码**：
- 相同逻辑出现3次或以上 → 必须提取
- 相同逻辑出现2次 → 判断是否有变化趋势

### 注释规范

- 注释解释"为什么"，而非"是什么"
- **禁止装饰性标记**：避免在代码注释中使用 emoji、特殊符号等装饰性标记
- 代码修改后同步更新注释
- 删除注释掉的代码

**说明**：
- 代码注释禁止使用装饰性符号（emoji、特殊字符等）
- 输出给用户的验证结果、提交信息可以使用文本标记（如 [通过]/[失败]）提高可读性
- 本规范文档为了结构清晰使用了一些格式标记，但实际代码中应遵守简洁原则

### 历史代码规范升级

- 修改历史代码时，发现不符合规范的必须一并修复
- 不得遗留技术债务

---

**工作流程规范结束**

> 本规范适用于所有项目，不要修改。项目特定规范请在 `project-spec.mdc` 中定义。
