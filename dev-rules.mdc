# 开发规范

> **本文档是通用的开发规范**，包含Bug排查、代码修改、TypeScript规范、测试规范等。

---

## Bug排查与验证规范

### 核心原则

**通过验证逐步缩小问题范围，让用户看到完整的分析过程**

排查bug时，不能直接猜测或跳跃式分析，必须通过实际验证来逐步确定问题出在哪一层。

### 禁止的错误模式

```
用户：X功能有bug
AI：我觉得可能是Y的问题（未验证）
    建议改Z（直接给方案）

结果：方案基于猜测，可能南辕北辙
```

### 正确的排查流程

```
用户：X功能有bug
AI：
  1. 理解问题：复述问题，确认理解正确
  2. 假设验证：提出2-3个可能的原因假设
  3. 逐层验证：从最底层开始验证
  
     验证1：DB层 - 查询数据库，数据是否存在？
     结论1：[数据存在] / [数据缺失]
     
     验证2：API层 - 调用接口，能否正确返回？
     结论2：[接口正常] / [接口异常]
     
     验证3：前端层 - 查看页面，数据是否显示？
     结论3：[显示正常] / [显示异常]
  
  4. 定位问题：根据验证结果，明确指出问题在哪一层
  5. 分析原因：阅读相关代码，找出根本原因
  6. 制定方案：提出修复方案，等待用户确认
  7. 实施修复：获得确认后执行修改
```

### 逐层验证方法

#### 第1层：数据层验证（DB Layer）

**目的**：确认数据本身是否存在、是否正确

```bash
# 验证数据是否存在
node -e "
const mysql = require('mysql2/promise');
(async () => {
  const conn = await mysql.createConnection({...});
  const [rows] = await conn.execute('SELECT * FROM users WHERE id = ?', ['123']);
  console.table(rows);
  await conn.end();
})();
"
```

**输出格式**：
```
═══════════════════════════════════════
【第1步：DB层验证】
═══════════════════════════════════════
查询：SELECT * FROM users WHERE id = '123'
结果：找到 1 条记录
[显示数据表格]

结论：DB层数据正常
═══════════════════════════════════════
```

#### 第2层：API层验证

**目的**：确认后端接口是否能正确处理和返回数据

```bash
# 验证API是否正常
curl --max-time 5 \
  "http://localhost:18100/api/users/123" \
  -H "Authorization: Bearer ${TOKEN}"
```

**输出格式**：
```
═══════════════════════════════════════
【第2步：API层验证】
═══════════════════════════════════════
请求：GET /api/users/123
响应：{"success": true, "data": {...}}

结论：
- DB层：数据存在
- API层：接口正常返回

问题范围缩小至：前端层
═══════════════════════════════════════
```

#### 第3层：前端层验证

**目的**：确认前端是否正确接收和显示数据

```typescript
// 在浏览器控制台执行
console.log('前端状态:', {
  apiResponse: window.lastApiResponse,
  displayedData: document.querySelector('.user-item')?.textContent
});
```

### 范围缩小策略

使用二分法逐步缩小问题范围：

```
全链路：浏览器 → 前端代码 → API请求 → 后端代码 → 数据库

第1次验证：检查数据库
  - [数据存在] → 问题在上层
  - [数据不存在] → 问题定位：数据写入逻辑

第2次验证：检查API
  - [API正常] → 问题在前端
  - [API异常] → 问题在后端

第3次验证：检查前端
  - 找到具体的文件、函数、代码行
```

---

## 代码修改防遗漏规范

### 核心原则

任何代码修改前必须执行完整性检查，确保一次性完成所有相关修改，避免碎片化提交。

### 五层检查法

见 `core-rules.mdc` 中的"代码完整性标准"章节。

### 检查清单

**验证环节**
- [ ] 每个假设都通过实际验证
- [ ] 验证结果以结构化格式输出
- [ ] 使用 [通过]/[失败] 明确标注验证结论
- [ ] 每次验证后说明当前问题范围

**分析环节**
- [ ] 列出2-3个可能的原因假设
- [ ] 从底层（DB）到上层（前端）逐层验证
- [ ] 定位到具体的代码文件和行号

---

## TypeScript 类型安全规范

### 核心原则

**严格禁止使用 `any` 类型**

### 规则

1. **禁止 `any`**
   ```typescript
   // 错误示例
   function handleData(data: any) { ... }
   
   // 正确示例
   function handleData(data: UserData) { ... }
   ```

2. **函数必须声明类型**
   ```typescript
   // 错误示例
   function calculate(a, b) { return a + b; }
   
   // 正确示例
   function calculate(a: number, b: number): number { return a + b; }
   ```

3. **使用 `unknown` 代替 `any`**
   ```typescript
   // 正确示例：需要类型守卫
   function processData(data: unknown) {
     if (typeof data === 'string') {
       return data.toUpperCase();
     }
   }
   ```

4. **充分利用泛型**
   ```typescript
   // 正确示例：保持类型安全
   function fetchData<T>(url: string): Promise<ApiResponse<T>> { ... }
   ```

### 常见场景

| 场景 | 错误做法 | 正确做法 |
|------|---------|---------|
| API响应 | `response: any` | `response: ApiResponse<UserData>` |
| 事件处理 | `event: any` | `event: React.ChangeEvent<HTMLInputElement>` |
| 配置对象 | `config: any` | `config: AppConfig` |
| 第三方库 | 使用 `any` | 定义 `.d.ts` 类型文件 |

---

## React 开发规范

**注意**：本节适用于前端 React 项目，后端项目可跳过。

### 组件规范

**组件命名**：
- 使用 PascalCase
- 文件名与组件名一致
- 一个文件一个主组件

**Props 类型**：
```typescript
// 正确示例：定义清晰的 Props 接口
interface UserCardProps {
  user: User;
  onEdit?: (id: string) => void;
  className?: string;
}

const UserCard: React.FC<UserCardProps> = ({ user, onEdit, className }) => {
  // ...
};
```

### Hooks 规范

**useState**：
```typescript
// 正确示例：明确类型
const [user, setUser] = useState<User | null>(null);
```

**useEffect**：
```typescript
// 正确示例：明确依赖项
useEffect(() => {
  fetchData();
}, [userId]); // 依赖项清晰
```

**自定义 Hook**：
```typescript
// 正确示例：返回类型明确
function useUser(id: string): { user: User | null; loading: boolean; error: Error | null } {
  // ...
  return { user, loading, error };
}
```

### 性能优化

- 使用 `React.memo` 优化组件渲染
- 使用 `useMemo` 缓存计算结果
- 使用 `useCallback` 缓存回调函数
- 避免在渲染函数中创建新对象/函数

---

## API 设计规范

### RESTful 规范

| 操作 | HTTP方法 | 路径示例 | 说明 |
|------|---------|---------|------|
| 列表 | GET | `/api/users` | 查询列表 |
| 详情 | GET | `/api/users/:id` | 查询详情 |
| 创建 | POST | `/api/users` | 创建资源 |
| 更新 | PUT | `/api/users/:id` | 完整更新 |
| 部分更新 | PATCH | `/api/users/:id` | 部分更新 |
| 删除 | DELETE | `/api/users/:id` | 删除资源 |

### 响应格式

```typescript
// 正确示例：统一的响应格式
interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: {
    code: string;
    message: string;
  };
}
```

### 错误处理

```typescript
// 正确示例：统一的错误码
enum ErrorCode {
  UNAUTHORIZED = 'UNAUTHORIZED',
  NOT_FOUND = 'NOT_FOUND',
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  INTERNAL_ERROR = 'INTERNAL_ERROR',
}
```

---

## 测试规范

### 单元测试

```typescript
// 正确示例：清晰的测试用例
describe('UserService', () => {
  describe('createUser', () => {
    it('should create user with valid data', async () => {
      // Arrange
      const userData = { name: 'John', email: 'john@example.com' };
      
      // Act
      const result = await userService.createUser(userData);
      
      // Assert
      expect(result).toBeDefined();
      expect(result.name).toBe('John');
    });
    
    it('should throw error with invalid email', async () => {
      const userData = { name: 'John', email: 'invalid' };
      await expect(userService.createUser(userData)).rejects.toThrow();
    });
  });
});
```

### 集成测试

- 测试完整的用户操作流程
- 从用户登录到功能使用的完整路径
- 验证多个模块之间的交互

---

## 性能优化规范

### 前端性能

1. **代码分割**：使用动态 import
2. **懒加载**：路由级别的懒加载
3. **图片优化**：使用 WebP 格式、懒加载
4. **缓存策略**：合理使用浏览器缓存

### 后端性能

1. **数据库查询优化**：
   - 添加必要的索引
   - 避免 N+1 查询
   - 使用分页

2. **API响应优化**：
   - 只返回必要的字段
   - 使用缓存（Redis）
   - 压缩响应数据

---

## 安全规范

### 输入验证

```typescript
// 正确示例：服务端必须验证所有输入
@Post('/users')
@Validate()
async createUser(@Body() userData: CreateUserDTO) {
  // userData 已经过验证
}
```

### 认证授权

```typescript
// 正确示例：使用装饰器进行权限控制
@Get('/admin/users')
@UseGuard(AuthGuard)
@RequireRole('admin')
async getUsers() {
  // 仅管理员可访问
}
```

### 敏感信息处理

- 密码必须加密存储
- Token 使用 JWT 并设置过期时间
- 日志中不输出敏感信息
- API 返回时过滤敏感字段

---

**规范结束**

> 本规范适用于所有项目，可根据技术栈适当调整。项目特定规范请在 `project-spec.mdc` 中定义。
