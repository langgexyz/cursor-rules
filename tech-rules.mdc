# 技术规范

> **本文档定义具体的技术标准和编码规范**，适用于各种技术栈。

---

## TypeScript 类型安全规范

### 核心原则

**严格禁止使用 `any` 类型**

### 规则

1. **禁止 `any`**
   ```typescript
   // 错误示例
   function handleData(data: any) { ... }
   
   // 正确示例
   function handleData(data: UserData) { ... }
   ```

2. **函数必须声明类型**
   ```typescript
   // 错误示例
   function calculate(a, b) { return a + b; }
   
   // 正确示例
   function calculate(a: number, b: number): number { return a + b; }
   ```

3. **使用 `unknown` 代替 `any`**
   ```typescript
   // 正确示例：需要类型守卫
   function processData(data: unknown) {
     if (typeof data === 'string') {
       return data.toUpperCase();
     }
   }
   ```

4. **充分利用泛型**
   ```typescript
   // 正确示例：保持类型安全
   function fetchData<T>(url: string): Promise<ApiResponse<T>> { ... }
   ```

### 常见场景

| 场景 | 错误做法 | 正确做法 |
|------|---------|---------|
| API响应 | `response: any` | `response: ApiResponse<UserData>` |
| 事件处理 | `event: any` | `event: React.ChangeEvent<HTMLInputElement>` |
| 配置对象 | `config: any` | `config: AppConfig` |
| 第三方库 | 使用 `any` | 定义 `.d.ts` 类型文件 |

---

## React 开发规范

**注意**：本节适用于前端 React 项目，后端项目可跳过。

### 组件规范

**组件命名**：
- 使用 PascalCase
- 文件名与组件名一致
- 一个文件一个主组件

**Props 类型**：
```typescript
// 正确示例：定义清晰的 Props 接口
interface UserCardProps {
  user: User;
  onEdit?: (id: string) => void;
  className?: string;
}

const UserCard: React.FC<UserCardProps> = ({ user, onEdit, className }) => {
  // ...
};
```

### Hooks 规范

**useState**：
```typescript
// 正确示例：明确类型
const [user, setUser] = useState<User | null>(null);
```

**useEffect**：
```typescript
// 正确示例：明确依赖项
useEffect(() => {
  fetchData();
}, [userId]); // 依赖项清晰
```

**自定义 Hook**：
```typescript
// 正确示例：返回类型明确
function useUser(id: string): { user: User | null; loading: boolean; error: Error | null } {
  // ...
  return { user, loading, error };
}
```

### 性能优化

- 使用 `React.memo` 优化组件渲染
- 使用 `useMemo` 缓存计算结果
- 使用 `useCallback` 缓存回调函数
- 避免在渲染函数中创建新对象/函数

---

## API 设计规范

### RESTful 规范

| 操作 | HTTP方法 | 路径示例 | 说明 |
|------|---------|---------|------|
| 列表 | GET | `/api/users` | 查询列表 |
| 详情 | GET | `/api/users/:id` | 查询详情 |
| 创建 | POST | `/api/users` | 创建资源 |
| 更新 | PUT | `/api/users/:id` | 完整更新 |
| 部分更新 | PATCH | `/api/users/:id` | 部分更新 |
| 删除 | DELETE | `/api/users/:id` | 删除资源 |

### 响应格式

```typescript
// 正确示例：统一的响应格式
interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: {
    code: string;
    message: string;
  };
}
```

### 错误处理

```typescript
// 正确示例：统一的错误码
enum ErrorCode {
  UNAUTHORIZED = 'UNAUTHORIZED',
  NOT_FOUND = 'NOT_FOUND',
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  INTERNAL_ERROR = 'INTERNAL_ERROR',
}
```

---

## 测试规范

### 单元测试

```typescript
// 正确示例：清晰的测试用例
describe('UserService', () => {
  describe('createUser', () => {
    it('should create user with valid data', async () => {
      // Arrange
      const userData = { name: 'John', email: 'john@example.com' };
      
      // Act
      const result = await userService.createUser(userData);
      
      // Assert
      expect(result).toBeDefined();
      expect(result.name).toBe('John');
    });
    
    it('should throw error with invalid email', async () => {
      const userData = { name: 'John', email: 'invalid' };
      await expect(userService.createUser(userData)).rejects.toThrow();
    });
  });
});
```

### 集成测试

- 测试完整的用户操作流程
- 从用户登录到功能使用的完整路径
- 验证多个模块之间的交互

---

## 性能优化规范

### 前端性能

1. **代码分割**：使用动态 import
2. **懒加载**：路由级别的懒加载
3. **图片优化**：使用 WebP 格式、懒加载
4. **缓存策略**：合理使用浏览器缓存

### 后端性能

1. **数据库查询优化**：
   - 添加必要的索引
   - 避免 N+1 查询
   - 使用分页

2. **API响应优化**：
   - 只返回必要的字段
   - 使用缓存（Redis）
   - 压缩响应数据

---

## 安全规范

### 输入验证

```typescript
// 正确示例：服务端必须验证所有输入
@Post('/users')
@Validate()
async createUser(@Body() userData: CreateUserDTO) {
  // userData 已经过验证
}
```

### 认证授权

```typescript
// 正确示例：使用装饰器进行权限控制
@Get('/admin/users')
@UseGuard(AuthGuard)
@RequireRole('admin')
async getUsers() {
  // 仅管理员可访问
}
```

### 敏感信息处理

- 密码必须加密存储
- Token 使用 JWT 并设置过期时间
- 日志中不输出敏感信息
- API 返回时过滤敏感字段

---

**技术规范结束**

> 本规范适用于所有项目，可根据技术栈适当调整。项目特定规范请在 `project-spec.mdc` 中定义。
