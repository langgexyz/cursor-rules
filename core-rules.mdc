# 核心工作原则与标准

> **本文档是所有项目通用的核心规范**，包含AI工作原则、Git规范、代码质量标准。

---

## AI工作原则

### 核心理念

**"用户很懒，只想看结果，不想自己操作"**

这不是贬义，而是对用户体验的深刻理解：
- 用户雇佣AI是为了**解决问题**，而非获得"解决问题的方法"
- 用户期望的是**"已完成"**，而非"您可以去做XXX"
- 验证、测试、确认都是AI的职责，不应转嫁给用户

### 六大原则

1. **主动性** - AI主动完成所有可自动化的工作，不推卸责任给用户
2. **完整性** - 每个任务必须完成验证、测试、文档更新的完整闭环
3. **透明性** - 所有操作、决策、验证结果必须清晰展示给用户
4. **责任感** - 对代码质量、功能正确性、用户体验负全责
5. **结果导向** - 用户只想看到"已完成"的结果，而非"可以去做"的建议
6. **规则优先** - 遇到需要决策时，优先查找规则

### 禁止的工作模式

| 错误模式 | 为什么错误 | 正确做法 |
|---|----|---|
| "请您测试一下" | 把验证责任推给用户 | AI主动验证并展示结果 |
| "如需验证，请登录查看" | 暗示用户需要自己验证 | AI验证完成后直接说"已验证通过" |
| "代码已修改，您部署后确认" | 不完整的工作闭环 | 创建TODO跟踪部署验证 |
| "这个问题可能是X原因" | 基于猜测而非验证 | 通过实际验证确定根本原因 |
| "修改了A，B可能也需要改" | 不确定的状态 | 执行完整性检查，一次性修改所有位置 |
| "API测试通过了" | 只测试底层，忽略用户操作路径 | 模拟用户完整操作流程验证 |

### AI的工作职责清单

**设计阶段**
- [ ] 理解需求，明确目标
- [ ] 识别所有需要修改的地方（完整性检查）
- [ ] 制定完整的实施方案

**实施阶段**
- [ ] 一次性完成所有相关修改
- [ ] 确保代码质量（命名、结构、注释）
- [ ] 编译检查通过

**验证阶段**
- [ ] 先验证用户操作路径（模拟用户完整操作流程）
- [ ] 再验证底层API（确认API返回正确数据）
- [ ] 使用自动化工具验证
- [ ] 截图记录验证结果
- [ ] 确认功能完全符合预期

**交付阶段**
- [ ] 展示验证结果（截图+说明）
- [ ] 更新TODO状态
- [ ] 总结："功能已完成并验证通过"
- [ ] 确保用户无需任何额外操作即可看到最终结果

---

## Git工作流标准

### 核心原则：边改边暂存

```bash
1. 修改一个小单元（函数/组件/配置）
2. 验证修改结果正确
3. git add <file>  # 立即暂存
4. 继续下一个修改
5. 如出错：git restore <file>  # 恢复到上次暂存
```

### 禁止操作

**禁止的文件操作**：
- `sed -i '' -e ...`
- `awk '...' file > temp && mv temp file`
- `echo "content" > file`
- `git checkout file`（使用 `git restore` 代替）

**关于自动格式化工具**：

禁止场景：
- 临时性的批量格式化（未经审查）
- 开发中途突然运行全局格式化
- 格式化未修改的文件

推荐场景：
- 项目初期配置好 `.prettierrc` 和 `.eslintrc`
- 使用 git hooks（husky + lint-staged）自动格式化暂存文件
- IDE 配置保存时自动格式化当前文件
- 只格式化本次修改的文件

### 推荐工具

- IDE提供的编辑工具
- `git restore <file>`
- `git diff`
- `git status`

### 错误恢复

| 场景 | 恢复命令 |
|---|---|
| 刚修改完，发现有问题 | `git restore file` |
| 已git add，想撤销暂存 | `git restore --staged file && git restore file` |
| 想恢复到更早的版本 | `git restore --source=<commit> file` |

---

## Git提交规范

### 核心理念：原子提交

```
原子提交 = 一个独立的、完整的、可测试的变更单元

推荐做法：
- 一个需求可以拆分成多个原子commit
- 每个commit都能独立编译、测试、回滚

禁止做法：
- 一个commit包含多个不相关的需求
- 因为遗漏而反复修改同一处
```

### 提交格式

```
<type>(<scope>): <subject>

<body>

<footer>
```

### type类型

- `feat`: 新功能
- `fix`: Bug修复
- `docs`: 文档更新
- `style`: 代码格式
- `refactor`: 重构
- `perf`: 性能优化
- `test`: 测试相关
- `chore`: 构建/工具链

### subject规范

- 使用中文描述
- 不超过50个字符
- 首字母小写
- 结尾不加句号

### body规范（记录完整工作过程）

- [检查过程]: 完整性检查的结果，识别了哪些位置
- [修改范围]: 修改了哪些文件/模块/函数
- [验证情况]: 用户操作路径/API/数据库验证结果
- [设计考虑]: 为什么这样做，有什么权衡

### 示例

```
feat(user): 用户筛选 - 添加UI组件 (#123)

[检查过程]:
- 多维度搜索：筛选/filter/search 相关代码
- 数据流分析：用户列表 → 筛选条件 → 过滤结果
- 识别修改：需要修改3个文件

[修改范围]:
- src/components/UserList.tsx: 添加筛选UI组件
- src/types/user.ts: 新增FilterParams类型定义

[验证情况]:
- 用户操作路径：登录 → 用户管理 → 选择部门筛选 (通过)
- UI交互：筛选条件变化时列表正确更新 (通过)

[设计考虑]:
- 筛选条件存储在URL参数，支持刷新保持状态
- 使用防抖优化搜索性能（300ms）
```

---

## 代码完整性标准

### 核心原则

修改前识别所有相关位置，避免遗漏导致的补充提交。

```
完整性检查的目的：
- 确保找到所有需要修改的位置
- 避免"改了这儿漏了那儿"
- 支持将完整的修改拆分成多个原子commit

完整性 ≠ 一个commit
完整性 = 不遗漏相关修改
```

### 完整性检查法（5层）

#### 第1层：多维度关键词搜索

```bash
# 业务层面
grep -rn "业务词1\|业务词2" src/

# 代码符号层面
grep -rn "函数名\|变量名" src/

# 技术实现层面
grep -rn "技术特征" src/
```

#### 第2层：功能流程分析

```
输入路径分析：
  1. 用户操作A → 事件处理A
  2. 用户操作B → 事件处理B

数据流分析：
  目标数据在哪些地方被：
  - 读取
  - 修改
  - 验证
  - 展示
```

#### 第3层：文件结构检查

```bash
# 列出所有函数定义
grep -n "export.*function\|const.*=.*(" file.tsx

# 列出所有Hooks
grep -n "useState\|useEffect" file.tsx
```

#### 第4层：代码阅读验证

- 完整阅读相关函数代码
- 检查所有分支逻辑（if/else）
- 验证注释是否需要更新
- 确认错误提示一致性

#### 第5层：交叉验证检查表

```
必须同步修改：
- [ ] 代码逻辑
- [ ] TypeScript类型
- [ ] 函数注释
- [ ] 错误提示文案
- [ ] 相关文档
```

---

## 验证标准

### 核心原则

AI主动验证，展示结果，不推卸责任，工作可追溯可验证。

### 验证优先级

```
1. 用户操作路径验证（最重要）
   └─ 登录 → 菜单 → 页面 → 功能 → 结果
   
2. 底层API验证
   └─ 接口 → 数据 → 状态
   
3. 数据库验证
   └─ 数据存在性 → 数据正确性
```

### 验证输出格式

**注意**：以下输出格式中可以使用状态标记（如 [通过]/[失败]）提高可读性，但在代码注释中禁止使用装饰性标记。

```
功能已完成并验证通过！

【验证流程】
1. 使用测试账号登录 [通过]
2. 点击目标菜单 [通过]
3. 页面正常加载 [通过]
4. 功能正常工作 [通过]

【验证截图】
[附截图]

【技术验证】
API: 接口返回正确 [通过]
数据库：数据一致 [通过]
```

---

## 代码质量标准

### 编译检查

- 所有代码修改后必须编译通过
- 不允许跳过编译检查

### 命名规范

- 变量/函数名：清晰、有意义，避免单字母
- 组件名：PascalCase
- 函数名：camelCase
- 常量名：UPPER_SNAKE_CASE

### 代码可维护性

**函数长度**：
- 单个函数不超过50行 → 超过必须拆分（除非特殊情况）
- 判断标准：函数的单一职责

**嵌套深度**：
- 不超过3层 → 超过必须重构
- 重构方式：提前return、提取函数

**注释要求**：
- 必须添加注释：非常规算法、业务规则、暂时性方案
- 不需要注释：代码本身清晰自解释的

**重复代码**：
- 相同逻辑出现3次或以上 → 必须提取
- 相同逻辑出现2次 → 判断是否有变化趋势

### 注释规范

- 注释解释"为什么"，而非"是什么"
- **禁止装饰性标记**：避免在代码注释中使用 emoji、特殊符号等装饰性标记
- 代码修改后同步更新注释
- 删除注释掉的代码

**说明**：
- 代码注释禁止使用装饰性符号（emoji、特殊字符等）
- 输出给用户的验证结果、提交信息可以使用文本标记（如 [通过]/[失败]）提高可读性
- 本规范文档为了结构清晰使用了一些格式标记，但实际代码中应遵守简洁原则

### 历史代码规范升级

- 修改历史代码时，发现不符合规范的必须一并修复
- 不得遗留技术债务

---

**规范结束**

> 本规范适用于所有项目，不要修改。项目特定规范请在 `project-spec.mdc` 中定义。
